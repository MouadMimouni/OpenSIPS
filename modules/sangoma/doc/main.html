<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sangoma JSR309 API: JSR309 API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>JSR309 API</h1>
<p>
<h3 align="center">1.0.0 </h3><h2><a class="anchor" name="overview">
Overview</a></h2>
The JSR309 API targets a large range of applications from a simple audio transcoding application to complex video conferencing application, by providing:<p>
<ul>
<li>media network connectivity to establish media streams</li><li>IVR functions to detect DTMF, play file...</li><li>ways to join and mix network connection to DTMF function to create conferences and call bridges</li></ul>
The API provides these services along with the Sangoma D-series cards. These cards have hardware accelerators that offloads the host processor(s). The API can use one or more Sangoma cards depending if the application requires less or more density.<p>
The following figure shows a high level architecture of an application that uses the JSR309 API.<p>
<div align="center">
<img src="highlevel-app-arch.png" alt="highlevel-app-arch.png">
</div>
<p>
<dl compact><dt><b>Note:</b></dt><dd>This API is inspired from the JSR309 API developped for Java. JSR309 is an API designed by Oracle and Hewlett-Packard to provide multimedia application developers with a generic Media Server abstraction interface. It defines both a programming model and an object model for MS control independent of MS control protocols. The Media Server Control API is not an API for a specific protocol. It uses the multiple and evolving MS capabilities available in the industry today to provide an abstraction for commonly used application functions such as multi party conferencing, multimedia mixing and interaction dialogs. Ref: JSR 309 - Overview of Media Server Control API, p. 13, <a href="http://jcp.org/en/jsr/summary?id=309">http://jcp.org/en/jsr/summary?id=309</a>, Copyright (c) 2007-2009 Oracle and/or its affiliates. (c) Copyright 2007-2009 Hewlett-Packard Development Company, L.P</dd></dl>
<h3><a class="anchor" name="dseries">
D-series cards</a></h3>
The D-series cards are divided in two groups of cards:<ol type=1>
<li>standalone cards</li><li>PCI/PCI-Express cards</li></ol>
<div align="center">
<img src="jsr309-api-arch.png" alt="jsr309-api-arch.png">
<p><strong>JSR309 components</strong></p></div>
 The <b>standalone cards</b> only require a power source and a connection to an Ethernet LAN. The D150 is a standalone card. The JSR309 API communicates with these cards via standard NIC card by using a proprietary control procol that runs over Ethernet. This protocol is not routable. Meaning that the server running the application that is using JSR309 API and the D150 should be located on the same LAN in order to communicate properly.<p>
The <b>PCI/PCI-Express cards</b> should be inserted in a PCI or PCI-Express slot of a standard PC that runs Linux. The user should install the device drivers for the D100/D500 cards. The Linux device drivers for these cards are provided with the JSR309 API package.<p>
The media realtime data (audio/video) never goes to the application and goes directly to the D-series.<p>
The following figure shows the media flow when JSR309 API is used with D100 card.<p>
<div align="center">
<img src="media-via-d100.png" alt="media-via-d100.png">
<p><strong>Media when using D100 card</strong></p></div>
 As you may have observed, the red arrow shows the media enterring by the standard NIC interface goes upto the Linux IP stac that routes the media toward the D100 cards via the D100 device driver.<p>
<div align="center">
<img src="media-via-d500.png" alt="media-via-d500.png">
<p><strong>Media when using D500 card</strong></p></div>
 For the D500 the media does not have to flow trough the standard NIC card. Instead, the media enters direcly on the card via one of the 2 Ethernet connectors avaiable on the card.<p>
<dl compact><dt><b>Note:</b></dt><dd>Never connect both Ethernet connectors to the same Ethernet LAN.</dd></dl>
<h2><a class="anchor" name="api_objects">
API Objects</a></h2>
The API is structured to provide three sets of functionnalities:<ol type=1>
<li>Media Group (DTMF detector function)</li><li>Media Mixer</li><li>Network Connection</li></ol>
<dl compact><dt><b>Note:</b></dt><dd>The current version of the API does not support: MediaMixing and DTMF detection function.</dd></dl>
The API contains the following core objects:<ul>
<li><a class="el" href="d8/d96/classsangoma_1_1jsr309_1_1MSControlFactory.html">sangoma::jsr309::MSControlFactory</a></li><li><a class="el" href="d6/d6e/classsangoma_1_1jsr309_1_1MediaSession.html">sangoma::jsr309::MediaSession</a></li><li><a class="el" href="d5/d26/classsangoma_1_1jsr309_1_1NetworkConnection.html">sangoma::jsr309::NetworkConnection</a></li><li><a class="el" href="d2/d20/classsangoma_1_1jsr309_1_1Joinable.html">sangoma::jsr309::Joinable</a></li><li><a class="el" href="d6/d14/classsangoma_1_1jsr309_1_1MediaConfig.html">sangoma::jsr309::MediaConfig</a></li><li>sangoma::jsr309::MediaGroup (Not Implemented)</li></ul>
<h3><a class="anchor" name="mscontrolfactory">
Media Server Control Factory</a></h3>
<a class="el" href="d8/d96/classsangoma_1_1jsr309_1_1MSControlFactory.html">sangoma::jsr309::MSControlFactory</a> is the entry point of JSR309 API. This class will configure the API using an XML configuration file, instantiate the Media Server and instantiate MediaSession objects. While instantiating a Media Session, the factory will also assign a Media Server instance to the Media Session.<h3><a class="anchor" name="mediasession">
Media Session</a></h3>
<a class="el" href="d6/d6e/classsangoma_1_1jsr309_1_1MediaSession.html">sangoma::jsr309::MediaSession</a> acts as a factory, or resource management container, for creating, configuring and releasing objects. It can be associated with a context of a specific set of media resources inside an application. From an API implementation standpoint a MediaSession is associated with an instance of a media server.<h3><a class="anchor" name="networkconnection">
Network Connection</a></h3>
<a class="el" href="d5/d26/classsangoma_1_1jsr309_1_1NetworkConnection.html">sangoma::jsr309::NetworkConnection</a> represents the external user agent and more specifically the multimedia leg part of it only. This object does not play a role in call control. It enables the application to reference and associate multimedia legs with specific calls, and facilitates the handling of SDP negotiation. A NetworkConnection's output stream can be joined several times to other objects, that is, an outgoing stream can be split multiple times. A MediaMixer is required when multiple streams need to be joined to a single NetworkConnection's input.<h3><a class="anchor" name="mediagroup">
Media Group</a></h3>
MediaGroup represents a group of general purpose resources, for example Player (file, stream, etc.), and signal detection resources reporting results through events. It can accept simultaneous and independent resource transactions like play() or receiveSignals() or detection of DTMF digits.<h3><a class="anchor" name="joinable">
Joinable</a></h3>
<a class="el" href="d2/d20/classsangoma_1_1jsr309_1_1Joinable.html">sangoma::jsr309::Joinable</a> objects can be joined together, with the ability to handle individual multimedia streams or direction independently: for example, MediaMixer.join (SEND, NetworkConnection.getJoinableStream(video)). Output streams can be Joined to many different objects. For example: - two NetworkConnections can be joined together to form a bridge. - a single NetworkConnection can be joined to a MediaGroup function to play a file or record a stream. - three NetworkConnections can be joined to a MediaMixer to form a conference.<h3><a class="anchor" name="mediaconfig">
Media Configuration</a></h3>
<a class="el" href="d6/d14/classsangoma_1_1jsr309_1_1MediaConfig.html">sangoma::jsr309::MediaConfig</a> objects are used to pass information extracted from the SDP to JSR309 API through a serie of helper functions, one for each SDP parameter required by the API. Basically this objects allows to specify media characteristics, such as:<ul>
<li>codecs (audio and video)</li><li>RTP stream IP address and port</li><li>enable/disable RTCP</li><li>enable DTMF relay</li><li>SRTP parameters</li><li>...</li></ul>
Please refer to the class documentation page for a complete list of properties that could be specified with this object.<h2><a class="anchor" name="usecases">
Use cases</a></h2>
This API could be used to create:<ul>
<li>a media transcoding server</li><li>an audio conferencing server (not supported with this version of the API)</li></ul>
<div align="center">
<img src="nc-joined-to-nc.png" alt="nc-joined-to-nc.png">
<p><strong>Two Network Connections Joined Together</strong></p></div>
 <div align="center">
<img src="audio-conference.png" alt="audio-conference.png">
<p><strong>Audio Conference Session</strong></p></div>
 <h2><a class="anchor" name="api_concepts">
API concepts</a></h2>
<h3><a class="anchor" name="join_concept">
Joinable</a></h3>
Joinable objects are devided in two categories: JoinableContainer and JoinableStream.<p>
A JoinableContainer can be a NetworkConnection, MediaGroup or MediaMixer. A JoinableContainer has a fixed number of JoinableStream which is determined when the object gets created. When joining two containers together, all the streams of container A is joined to its equivalent stream in container B (i.e. A.audio_stream to B.audio_stream, A.video_stream to B.video_stream).<p>
Join process can also be executed on JoinableStreams. Having this possiblity gives the user the flexibility to alter only one stream of container. This could be used, for example, to muted the audio stream of a participant in a video conferencing session.<p>
Join process can be executed in three directions: Send, Receive, Duplex.<p>
Suppose we have two joinable objects A and B, and that A joins B by calling<p>
A.Join(direction, B);<p>
<ul>
<li>When direction is set to Joinable::Direction::kDuplex: media flows in both directions between objects.</li><li>When direction is set to Joinable::Direction::kReceive: A will receive media from B, but won't send any media to B. The result would be the same if we had called B.Join(Joinable::Direction::kSend, A).</li><li>When direction is set to Joinable::Direction::kSend: A will send media to B, but won't receive any media from B. The result would be the same if we had called B.Join(Joinable::Direction::kReceive, A).</li></ul>
<h3><a class="anchor" name="stream_concept">
Stream</a></h3>
A JoinableStream represents a media stream channel (or port), of a given type: audio or video (not supported in this version). It is a Joinable and as such, can be used as an argument to join. A JoinableStream has always one parent JoinableContainer, and that parent cannot change. Operating on JoinableStreams instead of their JoinableContainer, enables stream-specific compositions, like muting only the video, or sending the video to a different object.<h2><a class="anchor" name="programing">
Programing Considerations</a></h2>
<h3><a class="anchor" name="prog_compilation">
Compilation</a></h3>
The Sangoma JSR309 API installation package installs the various header files required by your application in the folders /usr/include/jsr309 and /usr/include/sangoma. Make sure the /usr/include folder is accessible by your compiler.<p>
The libraries provided with JSR309 were compiled with gcc 4.1.2. Thus any GCC version newer than 4.1.2 could be used to build an application with the JSR309 libraries.<p>
Compiler: gcc-c++ 4.1.2 or higher version<h3><a class="anchor" name="prog_library">
Linking</a></h3>
Link your application with the library libjsr309.so.<p>
The Sangoma JSR309 API installation package installs the various libraries files required by your application in the folder /usr/lib. Make sure the /usr/lib folder is accesseible by your linker.<h3><a class="anchor" name="prog_model">
Programing Model</a></h3>
When using Sangoma's JSR309 API with its D-series cards, created MediaObjects (NetworkConnection, MediaMixer, DTMFDetector) are binded to a MediaServerConnection which is binded to an object on those cards.<p>
If this MediaServerConnection becomes unavailable, a MediaServerLostEvent will be generated. Hence, the user of this API must create an implementation of sangoma::jsr309::MediaServerLostListener class to handle those events properly. A pointer to an instance of this class' implementation can be passed to <a class="el" href="d6/d6e/classsangoma_1_1jsr309_1_1MediaSession.html">sangoma::jsr309::MediaSession</a> objects through the AddListener method.<h3><a class="anchor" name="thread_safety">
Multi-threading application</a></h3>
The API implementation is thread-safe. This means several concurrent threads can safely access any objects of the API.<h3><a class="anchor" name="object_life">
API Objects life cycle</a></h3>
When calling <a class="el" href="d8/d96/classsangoma_1_1jsr309_1_1MSControlFactory.html#39e68350fb72142f025075c781f11821">sangoma::jsr309::MSControlFactory::CreateMediaSession</a>, <a class="el" href="d6/d6e/classsangoma_1_1jsr309_1_1MediaSession.html#d053f71552c038f3d8ef602656b0c296">sangoma::jsr309::MediaSession::CreateNetworkConnection</a> or any other MediaObject creation methods, the user receives a raw pointer to those objects, so he is responsible of making sure those objects gets deleted.<p>
Sangoma suggests using smart pointers to encapsulate those pointers. See <a class="el" href="d5/df6/transcoding-sample_8cc-example.html">transcoding-sample::cc</a> for examples on using smart pointers.<h2><a class="anchor" name="configuration">
Configuration</a></h2>
JSR309 API uses two configuration file to work:<ul>
<li>General configuration file (config.xml)</li><li>DSeries card specific configuration file (vocallo.xml)</li></ul>
The file names given in paranthesis can be found in "/usr/share/sangoma/jsr309/samples/config/". The document jsr309-configuration-file_specification.pdf that can be found in "/usr/share/sangoma/jsr309/doc/", is a detailed document on those configuration files.<p>
The general configuration file gives users control over the API to enable or disable some of the features like rtcp. It also contains the path to the DSeries specific configuration file required by the API.<p>
The DSeries specific configuration file must be completed by the user prior to using the API. Some parameters in the configuration file given with the samples have default values, but most parameters are specific to the user's system. Here's what vocallo.xml file given with the samples looks like:<p>
<div class="fragment"><pre class="fragment">   &lt;?xml version="1.0" encoding="utf-8"?&gt;
   &lt;vocallo&gt;
     &lt;config&gt;
       &lt;cpu_usage_low_threshold&gt;80&lt;/cpu_usage_low_threshold&gt;
       &lt;cpu_usage_high_threshold&gt;90&lt;/cpu_usage_high_threshold&gt;
     &lt;/config&gt;
     &lt;device&gt;
       &lt;ifname&gt;eth1&lt;/ifname&gt;
       &lt;hwaddr&gt;ff-ff-ff-ff-ff-ff&lt;/hwaddr&gt;
       &lt;model&gt;D100&lt;/model&gt;
       &lt;module&gt;
         &lt;hwaddr&gt;ff-ff-ff-ff-ff-ff&lt;/hwaddr&gt;
         &lt;ip&gt;xxx.xxx.xxx.xxx&lt;/ip&gt;
         &lt;mask&gt;yyy.yyy.yyy.0&lt;/mask&gt;
         &lt;gw&gt;zzz.zzz.zzz.zzz&lt;/gw&gt; &lt;!-- Optional --&gt;
         &lt;eth_port&gt;0&lt;/eth_port&gt;
         &lt;udp&gt;
           &lt;begin&gt;14000&lt;/begin&gt;
           &lt;end&gt;16000&lt;/end&gt;
         &lt;/udp&gt;
         &lt;max_sessions&gt;800&lt;/max_sessions&gt;
         &lt;num_sessions_high_watermark&gt;800&lt;/num_sessions_high_watermark&gt;
         &lt;num_sessions_low_watermark&gt;750&lt;/num_sessions_low_watermark&gt;
       &lt;/module&gt;
     &lt;/device&gt;
   &lt;/vocallo&gt;
   </pre></div><p>
<dl compact><dt><b>Note:</b></dt><dd>If the client uses more than one card, he needs to add a &lt;device&gt;&lt;/device&gt; section for each additional cards in the configuration file and follow the following steps for each cards.</dd></dl>
First thing the user must do to complete the configuration file is to find the "ifname" and the card's "hwaddr" using ifconfig. User should also set the model of the card based on the card in his system.<p>
Then, the user needs to list all the modules on his card. To do so, the API installation also installs an executable file called sngtc_tool which allows to list the modules on a card, update the firmware, update the license etc. In this case, we only consider the list_modules command. (Please refer to README.txt for firmware/license update)<p>
The listing of modules on a card is done with the following command:<p>
<div class="fragment"><pre class="fragment">   sngtc_tool -dev ethx -list_modules
   </pre></div><p>
Output of this command should look like this when using a D500:<p>
<div class="fragment"><pre class="fragment">   #sngtc_tool -dev eth0 -list_modules

   Sangoma Transcoding Modules
   ===========================

   1. MAC=00-0c-90-1b-66-c4 Ver=01.04.03-B53-PR Capacity=480 EthPort=1

   2. MAC=00-0c-90-1b-66-a6 Ver=01.04.03-B53-PR Capacity=480 EthPort=1

   3. MAC=00-0c-90-1b-76-24 Ver=01.04.03-B53-PR Capacity=480 EthPort=1

   4. MAC=00-0c-90-1b-9a-78 Ver=01.04.03-B53-PR Capacity=480 EthPort=1

   5. MAC=00-0c-90-1b-6d-42 Ver=01.04.03-B53-PR Capacity=480 EthPort=1
   </pre></div><p>
From the output of sngtc_tool -list_modules, we need two elements:<ul>
<li>MAC address</li><li>EthPort</li></ul>
The MAC address needs to be put in &lt;hwaddr&gt;&lt;/hwaddr&gt; instead of ff-ff-ff-ff-ff-ff in the module section and EthPort needs to be put in &lt;eth_port&gt;&lt;/eth_port&gt;, still in the module section.<p>
The user then needs to fill the ip, mask, and, optionally, the gw to reach each module. He needs to also make sure that the udp port range is wide enough to match 2 times the number of &lt;max_sessions&gt; since we need a port for the rtp and 1 for the rtcp connection.<p>
Repeat the previous step, adding a &lt;module&gt;&lt;/module&gt; section for each module found by the tool.<p>
Please refer to jsr309-configure-file_specification.pdf for details on the other parameters.<h2><a class="anchor" name="examples">
Examples</a></h2>
The API comes with fully documented example code that illustrates how to use the API to build various type of applications.<h3><a class="anchor" name="building_examples">
Buidling Examples</a></h3>
Examples of JSR309 API usage can be found, after installation, in /usr/share/sangoma/jsr309/samples. To build those examples, you need to have the following packages installed on your system:<p>
<ul>
<li>cmake version &gt;= 2.6</li><li>gcc &gt;= 4.1.2</li><li>gcc-c++ &gt;= 4.1.2</li></ul>
Then go in the samples directory and create a build directory:<p>
<div class="fragment"><pre class="fragment">   cd /usr/share/sangoma/jsr309/samples
   mkdir build
   </pre></div><p>
Run cmake that will generate all the files required to build the samples:<p>
<div class="fragment"><pre class="fragment">   cd build
   cmake ..
   </pre></div><p>
Once this is done, you can build the samples using standard make commands:<p>
<div class="fragment"><pre class="fragment">   make
   </pre></div><h3><a class="anchor" name="running_examples">
Running Examples</a></h3>
First thing to do is to populate the configuration file and vocallo configuration files with your system information.<p>
The configuration files required by the transcoding sample can be found in /usr/share/sangoma/jsr309/samples/config. The files are:<p>
<ul>
<li>config.xml</li><li>vocallo.xml</li><li>jsr309-logger.properties</li></ul>
The file "config.xml" contains general parameters to control the API like the desired codecs, is rtcp enabled, does the api needs to support rfc2833, etc.<p>
The file "vocallo.xml" contains information specific to DSeries cards that the API needs to configure and communicate with the cards. This includes parameters like the interface name (ifconfig), the inteface's MAC address, the model, modules MAC addresses, IP information, etc.<p>
Details on those files parameters can be found in the document <a href="/usr/share/sangoma/jsr309/doc/jsr309-configuration-file_specification.pdf" 
>jsr309-configuration-file_specification.pdf</a><p>
To demonstrate how to plug in a logger for the API, the transcoding sample uses a Sangoma implemented logger based upon log4cplus library (<a href="http://log4cplus.sourceforge.net">http://log4cplus.sourceforge.net</a>). The jsr309-logger.properties file is used to configure the log4cplus logger.<h4><a class="anchor" name="jsr309-transcoding-sample">
jsr309-transcoding-sample</a></h4>
<div class="fragment"><pre class="fragment">   usage: jsr309-transcoding-sample &lt;config_file&gt; &lt;call_A_ip&gt; &lt;call_B_ip&gt; &lt;logger_properties_file (optional)&gt;
   </pre></div><p>
This example creates two network connections and join them together. To stop the process and unjoin them, the program waits for any key to be enterred on the keyboard followed by "ENTER". If the user created to user agents, one on call_A_ip:14000 and one on call_B_ip:15000, call A sending PCMU packets and call B sending PCMA packets, user will have a full transcoding session.<p>
<a class="el" href="d5/df6/transcoding-sample_8cc-example.html">transcoding-sample::cc</a><h2><a class="anchor" name="diagnostic">
Diagnostic</a></h2>
<h3><a class="anchor" name="logging">
Logging</a></h3>
JSR309 API log statements are divided in 6 levels:<ul>
<li>sangoma::TRACE_LOG_LEVEL (lowest severity)</li><li>sangoma::DEBUG_LOG_LEVEL</li><li>sangoma::INFO_LOG_LEVEL (default level)</li><li>sangoma::WARN_LOG_LEVEL</li><li>sangoma::ERROR_LOG_LEVEL</li><li>sangoma::FATAL_LOG_LEVEL (highest severity)</li></ul>
The log level can be set upon the creation of the logger instance (see <a class="el" href="da/d49/transcoding-sample_8cc.html">transcoding-sample.cc</a>). Once the log level is decided, only the log statement with a log level higher or equal in severity will output.<p>
The sangoma::TRACE_LOG_LEVEL is mostly used to trace every function entry and exit. This is a really verbose level and should not be used except for extreme condition.<p>
The sangoma::DEBUG_LOG_LEVEL is used to locate and solve issues in the API. It is usually used to give user debugging information at critical points in a function.<p>
The sangoma::INFO_LOG_LEVEL is used to give user information on the system's state.<p>
The sangoma::WARN_LOG_LEVEL is used to illustrate a situation that is should not happen in a normal course of action and could be harmful to the system in the long term. User should pay attention to this situation.<p>
The sangoma::ERROR_LOG_LEVEL is used when an error occured but the system might still be able to continue running.<p>
The sangoma::FATAL_LOG_LEVEL is used when a major problem occurs in the system that prevents the API from working properly.<p>
If the client uses sangoma's implemenation of <a class="el" href="de/d83/classsangoma_1_1Logger.html">sangoma::Logger</a> as in <a class="el" href="da/d49/transcoding-sample_8cc.html">transcoding-sample.cc</a>, the log level can be set through a properties file like jsr309-logger.properties. <hr size="1"><address style="align: right;"><small>Generated on Wed Jan 11 01:08:51 2012 for Sangoma JSR309 API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
